# 프로토타입

자바스크립트를 이루고 있는 거의 모든 것이 객체이다.

## 객체지향 프로그래밍

객체지향 프로그래밍은 실제 사물을 인식하는 사고를 프로그래밍에 접목하려는 시도에서 시작되었다. 실체는 특징이나 성징을 나타내는 속성을 가지고 있고, 이를 통해 구별 할 수 있다. 이 필요한 속성만 간추려 내어 표현하는 것을 추상화 라고 한다.

- 객체 지향에서의 객체란?
  속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조이다.

## 상속과 프로토타입

상속을 통해 불필요한 중복을 제거할 수 있다. 이 때 자바스크립트는 프로토타입을 기반으로 상속을 구현한다.

## 프로토타입 객체

객체간 상속을 구현하기 위해 사용된다. 객체가 생성될 때 객체 생성방식에 따라 프로토타입이 결정되고 `[[prototype]]` 이라는 내부 슬럿에 저장된다. 모든 객체는 하나의 프로토타입을 가지고 모든 프로토토타입은 생성자 함수ㅜ와 연결되어 있다.

- `__proto__` 접근자 프로퍼티
  모든 객체는 `__proto__` 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 `[[protottype]]` 내부 슬롯에 간접적으로 접근할 수 있다.
  - 그럼 왜 `__proto__` 접근자 프로퍼티를 통해 프로토타입에 접근할까?
    프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함.
    프로토타입 체인은 단방향 링크드 리스트로 구현되어야함. 순환 체인이 만들어지면 체인 종점이 존재하지 않아서 프로퍼티를 검색할 때 무한 루프에 빠짐
    그래서 무조건 적으로 프로토타입을 교체할 수 없도록 `__proto__` 접근자 프로퍼티를 통해 프로토타입에 접근하고 교체하도록 구현되어 있다.
  - 그럼 우리는 `__proto__` 를 코드에서 사용해야할까?
    결론부터 말하면 권장하지 않는다. 모든 객체가 `__proto__` 접근자 프로퍼티를 사용할 수 있는 것은 아니다. 만약 접근자 프로퍼티 대신 프로토타입 참조를 취득하고 싶다면 `Object.getPrototypeOf` 메서드를 사용하고 교체하고 싶은 경우는 `Object.setPrototypeOf` 메서드를 사용해라.
- 함수 객체의 prototype 프로퍼티
  함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로퍼티를 가르킨다. 이때 non-constructor인 화살표 함수로 쓰면 prototype 프로퍼티를 소유하지 않으며 프로토타입도 생성하지 않는다.
  이게 무슨 말이냐면 prototype 프로퍼티와 `__proto__` 접근자 프로퍼티로 프로토타입 객체에 접근하면 동일하단 의미이다.
- 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다.

  - 프로토타입은 그럼 언제 생성될까? ⇒ 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다. 이우는 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 때문
  - constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다. 하지만 non-constructor는 생성자 함수로써 호출할 수 없어서 프로토타입이 존재하지 않는다.

- 빌트인 생성자 함수와 사용자 정의 생성자 함수
  - 사용자 정의 생성자 함수는 자신이 평가되어 함수 객체로 생성되는 시점에 프로토타입도 더불어 생성되며, 생성된 프로토타입으 ㅣ프로토타입은 언제나 Object.prototype이다.
  - 빌트인 생성자 함수도 생성 시점에 프로토타입이 생성된다. 이때 전역 객체가 생성되는 시점에 생성되고 생성된 프로토타입은 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩된다.
    - 이게 무슨 말이냐면 생성자 함수와 프로토타입은 이미 객체화 되어 존재하기 때문에 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체에 내부슬롯에 할당되어 객체는 프로토타입을 상속받는다.

## 프로토타입 체인

자바스크립트는 객체의 프로퍼티에 접근할려고 할 때 해당 객체에 접근하려면 프로퍼티가 없다면 `[[prototype]]` 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라고 한다. 프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘이다.

- 이때 프로포타입의 최상위 객체는 뭘까?
  - 언제나 Object.prototype 이다. 따라서 모든 객체는 이를 상속받고 이를 프로토타입 체인의 종점이라고 한다.

## 프로토타입 교체 및 삭제

프로토타입 교체나 상속관계를 동적으로 변경하는 것은 번거롭다 . 그러니 직접 교체하지 말고, 직접 상속을 사용하거나 es6에서 도입된 클래스를 사용하면 간편하고 직관적으로 상속 관계를 구현할 수 있다.

## instanceof 연산자

우뱐의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true, 아니면 false 를 평가.

## 직접상속

- Object.create에 의한 직접 상속
  - Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성함.
    - 장점?
      - new 연산자 없이도 객체 생성 가능, 프로토타입을 지정하면서 객체 생성 가능, 객체 리터럴에 의해 생성된 객체도 상속 가능

## 프로퍼티 존재확인

in 연산자는 확인대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의가 필요.

그래서 es6에서 도입된 reflect.has 연산자를 사용하면 동일하게 구현 가능.

- Object.prototype.hasOwnProterty 메서드를 사용해도 객체에 특정 프로퍼티가 존재하는지 확인 가능

## 프로퍼티 순환

for… in 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 `[[enumerable]]` 의 값이 true인 프로퍼티를 순회하며 열거함

그럼 우린 뭘 써야하는가?

- for…in 문은 프로퍼티를 열거할 때 순서를 보장하진 않음. 하지만 대부분의 모던 브라우저는 순서를 보장하고 숫자인 프로퍼티 키에 대해서는 정렬을 함.
- 배열에는 for…in 문을 사용하지 말고 for이나 for..of, array.prototype.forEach 메서드를 사용하는 것이 권장됨

for … in 문은 객체 자신의 고유 프로퍼티 말고도 상속받은 것을 열거 그래서 객체 자신의 고유 프로퍼티만을 열거하기 위해서는 Object.keys, values, entries 메서드를 사용하는 것이 권장됨

# 21장 . 빌트인 객체

- 자바스크립트 객체는 세개로 분류

  - 표준 빌트인 객체 : ecmascript 에 정의된 객체, 브라우저 나 node.js 와 같은 실행환경과 관계 없이 사용가능
  - 호스트 객체 : ecmascript에 정의되어 있지 않지만 실행 환경에서 추가로 제공하는 객체
    - 브라우저 환경 : DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, web storagem web component, web workert 와 같은 클라이언트 사이드 web apirk wprhdehla
    - node.js 환경에서는 node.js 고유의 api를 호스트 객체로 제공
  - 사용자 정의 객체 : 제곧네

- 원시값과 래퍼 객체

  - 문자열, 숫자, 불리언등의 원시겂이 있는데 왜 표준 빌트인 생성자 함수가 있는걸까?
    - 일단 원시값은 객체가 아님. 근데 객체처럼 동작함. 이유는 엔진이 암묵적으로 연관된 객체로 변환해주고 다시 돌려놓기 때문임.
    - 문자열, 숫자, 불리언 값에 대해서 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라고 한다.
    - 그럼 우린 이걸 써야할까?

- 전역 객체

  - 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체, 어떤 객체에도 속하지 않은 최상위 객체이다.
    - 브라우저에서는 window, node 에서는 global 임

- 전역객체의 특징
  - 전역 객체는 개발자가 의도적으로 생성할 수 없다. (생성자 함수를 제공하지 않음)
  - 전역 객체의 프로퍼티를 참조할 때 window 또는 global을 생략할 수 있다.
  - 전역 객체는 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.
  - 자바스크립트 실행환경에 따라 추가적으로 프로퍼티와 메서드를 갖는다.
  - var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.
  - let이나 const 로 선언한 전역변수는 전역 객체의 프로퍼티가 아니다. let 이나 const 키워드로 선언한 전역변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재하게 된다.
  - 브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window 를 공유한다. 여러 개의 script 태그를 통해 자바스크립트 코드를 분리해도 하나의 전역 객체 window 를 공유하는 것은 변함이 없다.

# this

this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

이때 this 가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.

- 전역에서 this는 전역 객체 window 를 가리킨다.
- 일반 함수 내부에서는 this 는 전역 객체 window 를 가리킨다. (중첩 함수, 콜백 함수도 동일)
- 메서드 내부에서 this 는 메서드를 호출한 객체를 가리킨다.
- 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다.

이때 함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다. 하지만 this 바인딩은 함수 호출 시점에 결정된다.

⇒ 렉시컬 스코프와 this 바인딩은 결정 시기가 다르다.

- Function.prototype.apply/call/bind 메서드에 의한 간접 호출
  - apply와 call 메서드의 본질적인 기능은 함수를 호출하는 것이다. 위 메서드는 함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this 에 바인딩 한다.
- bind 메서드는 메서드의 this 와 메서드 내부의 중첩 함수 또는 콜백 함수의 this를 묶어주기 위함
