# 3주차(9장 ~ 11장)

# 타입변환과 단축 평가

## 9.1 타입 변환이란?

개발자가 의도적으로 값의 타입을 바꾸는 것이다. 타입 캐스팅이라고도 부른다.

명시적으로 타입을 바꿔줄 수도 있고 암묵적으로 바꿔줄 수 도 있다.

그럼 어떠한 방법이 더 좋을까? 정답은 없다. 암묵적 타입이 더 가독성이 좋을 수도 있기 때문이다. 따라서 중요한 것은 예측할 수 있는 코드를 작성하는것이 더 중요하고 동요가 자신의 코드를 정확히 이해할 수 있어야 한다.

## 9.2 암묵적 타입 변환

자발자의 의도와는 상관없이 코드의 문맥을 고려해서 데이터 타입을 강제 변환하는 것

### Truthy 와 Falsy

자바스크립트 엔진은 때론 불리언 타입이 아닌 값을 Truthy 값(참으로 평가 되는 값) 또는 Falsy (거짓으로 평가되는 값) 으로 구분한다.

```jsx
// falsy 값
false
undefined
null
-, -0
NaN
''

// 이 외에 모든 값은 truthy
```

## 9.3 명시적 타입 변환

명시적으로 타입을 변경하는 방법은 다영한데 (String, Number, Boolean)를 new 연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법, 암묵적 타입변환을 이용하는 방법이 있다.

## 9.4 단축 평가

논리 연산의 결과를 결정하는 피연산자를 타입변환 하지 않고 그대로 반환한다. 이를 단축 평가 라고 한다. 단축 평가는 표현식을 평가하는 도중에 결과 결과가 확정된 경우 나머지 평과 과정을 생락하는 것을 말한다.

여기서 코드 꿀팁은 if문을 대체할 수 있다는 것이다.

- 어떤 조건이 Truthy 값 일때 무언가를 해야한다면 논리곱으로 표현

  ```jsx
  if (done) message = 'done';

  message = done && 'done';
  ```

- 어떤 조건이 Falsy 값 일때 무언가를 해야한다면 논리합으로 표현

```jsx
if (!done) message = 'done';

message = done || 'done';
```

- 우리가 자주 사용하는 패턴에서도 단축평가가 있다.

```jsx
const someValue = value && value.key;
// value가 null이나 undefined 같은 Falsy 값이면 value 로 평가되고
// value가 truthy 값이면 value.key 로 평가 된다.
```

옵셔널 체이닝 연산자를 통해서도 평가 가능. `?.` 연산자를 통해서 좌항의 피연산자가 null 또는 undefined 의 경우 undefined 를 반환하고 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.

- null 병합 연산자.

기본값 변수 설정할 때 유용하다. 만약 `||` 를 사용해서 단축평가를 하게 된다면 falsy한 값이면 피연산자를 반환하는데 0이나 ‘’ 도 기본값으로 사용한다면 `??` 연산자를 쓰는 것이 좋다. falsy 한 값이라도 null 또는 undefined 가 아니면 좌항의 피연산자를 그대로 반환하기 때문이다.

# 10장 객체 리터럴

## 객체란?

자바스크립트의 모든것은 객체이다. 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체이다.

객체 : 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 key와 value로 구성된다. 이때, 프로퍼티 값이 함수일 때는 일반함수와 구분하기 위해 메서드라는 표현을 쓴다.

## 객체 리터럴에 의한 객체 생성

클래스를 정의하고 new 연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식. 이때 자바스크립트는 프로토타입 객체지향 언어기 때문에 클래스 언어와 달리 여러 방법을 지원하는데 이때 가장 쉬운게 `{}` 로 표기하는 객체 리터럴 방식이다.

### 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.

다만 주의할 점은 타입스크립트에서는 컴파일 단계에서 타입을 지정하기 때문에 동적인 값을 추가 시 에러가 난다.

# 11장 원시 값과 객체의 비교

데이터 타입은 크게 원시 타입과 객체 타입으로 구분할 수 있다. 그렇다면 두개의 차이는 무엇일까

- 원시 값은 변경 불가능한 값이다. 이에 비해 객체 타입의 값, 즉 객체는 변경가능한 값이다.
- 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달 (pass by value) 라 하고 객체를 가리키는 변수를 다른 변수에 할당하면 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(pass by reference)라고 한다.

## 원시 값

변경 불가능한 값, 즉 읽기 전용 값이다.

원시 값의 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 이러한 특성을 불변성이라고 한다.

왜 그럼 불변성이 필요할까?

⇒ 만약 재할당 이외에 원시 값인 변수 값을 변경할 수 있다면 예기치 않게 변수 값이 변경될 수 있다는 것을 의미한다. 이는 값의 변경, 즉 상태 변경을 추적하기 어렵게 만든다.

## 값에 의한 전달

값에 의한 전달도 사실은 값을 전달하는 것이 아닌 메모리 주소를 전달한다. 단 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.

중요한 것은 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이기 때문에 한쪽에서 재할당을 통해 변경핟라도 서로 간섭할 수 없다는 것이다.

```jsx
var score = 80;
var copy = score; // copy 변수에는 score 변수의 값 80이 복사되어 할당

console.log(score); // 80;
console.log(copy); // 80;

// score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값
// 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영행도 주지 않음
score = 100;

console.log(score); // 100;
console.log(copy); // 80;
```

## 객체

객체는 원시 값과 같이 확보해야할 메모리 공간의 크기를 사전에 정의해두지 않는다.

자바스크립트의 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블 이라고 생각할 수 있다. 자바나 C++같은 클리스 기반 언어는 사전에 정의된 클래스를 기반으로 객체(인스턴스)를 생성한다. 이 뜻은 객체를 생성하기 이전에 이미 프로퍼티와 메서드가 정해져 있으며 그대로 객체로 사용.

하지만 자바스크립트는 클래스 없이 객체를 생성할 수 있으며 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드를 추가할 수 있다. 이는 사용하기 매우 편리하지만 성능 면에서는 이론적으로 클래스 기반 객체지향 프로퍼티 언어의 객체보다 생성과 프로퍼티 접근에 비용이 . 더많이 드는 비효율적인 방식이다.

그래서 V8 자바스크립트 엔진에서는 히든 클래스 라는 방식을 사용해서 성능을 보장한다. 히든 클래스는 자바와 같이 고정된 객체 레이아웃(클래스)과 유사하게 동작함.

히든 클래스는 객체의 속성 변경이 발생할 때마다 객체의 구조를 나타내는 새로운 클래스를 생성하고 캐시하여, 동일한 구조의 객체에 대한 속성 접근이 더 빠르게 이루어지도록 최적화합니다.

---

객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 재할당 없이 프로퍼티를 동적으로 추가, 갱신, 삭제 할 수 있다.

이때 값을 변경할 경우 객체를 할당항 변수의 참조 값은 변경되지 않는다.

왜 그럼 객체는 불변성을 유지하지 않는 걸까?

→ 객체의 크기는 매우 클 수도 있고 원시 값처럼 크기가 일정하지 않으며 프로퍼티 값이 객체일 수도 있어서 복사에서 생성하는 비용이 많이든다. 메모리 효율적 소비가 어렵고 성능이 나빠진다.

→ 그렇다면 장점만 있을까?

객체는 이러한 구조적 단 때문에 여러개의 식별자가 하나의 객체를 공유할 수 있다는 문제점이 있다.

## 얕은 복사와 깊은 복사의 차이

객체를 프로퍼티 값으로 갖는 객체의 경우 한 단계 까지만 복사하는 것을 말하고, 깊은 복사는 객체에 중첩되어 있는 모든 객체까지 모두 복사하는 것을 말한다.

두 복사 모두 원본과 다른 객체가 만들어진다. 하지만 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조값을 복사하고 깊은 복사는 중첩되어 있는 것까지 모두 복사해서 원시 값처럼 완전한 복사본은 만든다는 차이가 있다.

이떄 위에서 말한 여러개의 식별자가 하나의 객체를 공유할때 생기는 문제점이 발생하는데, 얕은 복사 . 시두개의 식별자가 하나의 객체를 공유하게되면서 어떠한 하나가 변경되게되면 서로 영향을 주고받을 수 있다는 점이다.

그래서 결국 값에 의한 전달과 참조에 의한 전달은 결과적으로 메모리 공간에 저장도어 있는 값을 전달하는 것이다. 그래서 자바스크립트에는 참조에 의한 전달은 존재하지 않고 값에 의한 전달만 존재한다.
